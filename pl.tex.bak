\section{What Does This Mean for Us?}
\label{sec:PL}


In this section, we argue that middleboxes are interesting from program language and verification perspectives.
In \secref{MidDefinition}, we define the semantics of middleboxes in a generic way.
The problem of verification of verifying a network of middleboxes is addressed in \secref{Verification}.
Finally, \secref{Comp} addresses the problem of compositional network verification.

\subsection{Formalizing the semantics of Middleboxes}
\label{sec:MidDefinition}


Let $P$ denotes the potentially infinite set of packets.
We assume that packets can include various fields including source-host, target-host , etc.
For simplicity, we assume that input-ports and output-ports are parts of the packet headers.
\begin{Definition}\label{def:Middlebox}
\begin{Name}Middlebox Semantics
\end{Name}
The \textbf{semantics} of a middlebox is a function  $m\colon P \times P^* \to 2^P$, i.e., for every input packet $p$, and a history of packets $h$, the middlebox
produces a set of packets $m(p, h)$.
\end{Definition}

\notemooly{Do we want to include a table with common middkeboxes?.}\notescott{we've already listed common middleboxes in the introduction.}
The empty set of packets is produced when the packet is dropped.
A switch is a degenerate case in which $m(p, h) = \{p\}$ for all $h$ and $p$.
A NATs maps local into a unique global IP address.
A load-balancer can rewrite the packet to change its subsequent routing.
It can also update its policy as it sees more packets.
A cache proxy rewrites the first request to originate from the current node
and stores the response in a local table.
Arriving packets with stored responses are re-routed to the source with the stored responses in the packet body .

\subsubsection{Middlebox Models}
Middlebox models have \emph{abstract local states} which realize their intended semantics.
This is captured in the following definition.
\begin{Definition}\label{def:AbstractMiddlebox}
\begin{Name}Abstract Middlebox Models\end{Name}
Let $m\colon P \times P^* \to 2^P$ be a middlebox.
Let $S_m$ be a set of \textbf{abstract states} of $m$ and $s_0 \in S_m$ be the \textbf{initial abstract state} of $m$.
\textbf{An abstract model of middlebox} $m$ is a function
$
\hat{m}\colon (S_m \times P) \to (S_m \times 2^P)
$
such that for every history $h \in P^*$ and packet $p \in P$,
$
m(h, p) = \widehat{m}(\semp{h}(s_0),p)_2
$
where $\semp{h}\colon S_m \to S_m$ denotes the middlebox abstract state after the execution of the history $h$.
It is inductively defined by:
$
\semp{\epsilon}(s_0) = s_0
$
and
$
\semp{h.p'}(s_0) = \widehat{m}(\semp{h}(s_0), p')_1
$.
\end{Definition}

Notice that $S_m$ denotes the abstract states of the system; the real implementation is much more complex.
Also notice that $S_m$ is unbounded in many cases.
For example, a Firewall middlebox memorizes the set of targets sent from trusted hosts.

\subsection{The Verification Problem}
\label{sec:Verification}
The area of program verification has gone a long way from the seminal works of Floyd, Hoare, and Dijkstra.
The biggest problem of program (and network) verification as already observed in \cite{popl:DeMilloLP77} is the absence of exact specification of what the system intends to do.
For example, we do not see how to exactly formalize the correctness of middleboxes like Intrusion Detected System(IDS).

\subsubsection{Network Isolation}
The most important safety problem for networks is \textbf{network isolation}, i.e., prove the absence of
paths between certain parts of the network.
Network isolation comes in many flavors.
The simplest form is requiring that certain hosts cannot send certain types of packets to certain hosts.
For example, different virtual networks should be disconnected even when they reside in the same physical network.
Also, certain hosts cannot send SSH packets.
A refinement of the isolation problem is assuring that the content of the packets sent from certain hosts cannot reach
certain hosts.
Such a violation can occur for example when proxies are inserted.

We believe that network isolation requirements can be easily specified by network administrators~\cite{Congress}.
Furthermore, they are similar to memory safety in the sense that violation of network isolation can actually be the consequence
of a logical error in the implementation.

\subsubsection{Misconfiguration Errors}
A recent study in the network community indicates that 43\% of network failures occur due to misconfiguration errors~\cite{IMC:RJ13}.
For example, \figref{Miss1} shows a simple misconfiguration error when a new proxy is connected to the network, thereby
the proxy hides the source from the Firewall.
As a result host $A$ is no longer isolated from $B$.
\figref{LoadIDS} shows another bug which can happen when a new load-balancer is added in order to improve the network performance.
Lets assume that the IDS limits the number of paths from some host $A$.
If the load-balancer reroutes two packets from $A$ to different
As a result packets from the same host can be rerouted to different intrusion detection systems.
A remedy do this problem is to ensure that the load balancer uniquely route packets from the same source.
\begin{figure}
\caption{\label{fi:Miss1}%
A Proxy which leads to violation of network isolation.}
\end{figure}


\begin{figure}
\caption{\label{fi:LoadIDS}%
A load-balancer inserted before intrusion detection systems which leads to violation of network isolation.}
\end{figure}

\subsubsection{The Complexity of Checking Network Correctness}
We now address the question of checking the correctness of network of middleboxes.
We begin with an obvious consequence of Rice Theorem:
\begin{theorem}
\begin{Name}Undecidability of network correctness\end{Name}
Consider a fixed topology of middleboxes.
Also assume that the semantics of every middlebox is expressed in Turing Complete programming language.
Then, it is undecidable to check any non-trivial property of networks, e.g., network isolation.
\end{theorem}

We are currently working on a programming language for specifying abstract middleboxes which allows to algorithmically check
interesting network properties including network isolation.
Despite this theorem, there may exist restricted programming languages for expressing the abstract effects of many mddleboxes that allows to algorithmically check many interesting
properties such as absence of loops and packet isolation.






\subsection{Compositional Reasoning on Networks of Middleboxes}
\label{sec:Comp}
The holy grail of programming languages has been to provide mechanisms for building complex software systems using smaller components.
Ideally, it should be possible reason about the correctness of the system in a \emph{compositional} way --- the correctness of a
complex system should follow the correctness of the individual components.
For example, rely-guarantee~\cite{tse:MisraC81,ifip:Jones83}, is a compositional method for reasoning about concurrent systems.
Compositional methods reduce the cost of reasoning and enables reasoning about changes to the systems.
Compositional reasoning is especially attractive since verification technologies usually incur high costs.
In this section, we argue that middleboxes enable in many cases to reason compositionally on the correctness of the data-plane.


\subsubsection{Middleboxes are ADTs}
Abstract data types (ADTs) are effective way to build reliable and efficient software.
Indeed data abstraction is one of the key techniques for reasoning about programs (e.g., see \cite{acta-inf:H72}).
It is not clear how to use abstract data types to handle the data plane which is viewed as a flat hardware based system.
SDN controller programs are usually written in high level languages such as Python and Java which offer various modularity mechanisms.
However, these do not help with modularly handling the data-plane.

We believe that middleboxes are somewhat analogous to ADTs.
We have already shown that the abstract specification of middleboxes is much simpler than their concrete implementations.
It should be possible to verify certain correctness properties of the network, e.g., packet isolation without the need to analyze the concrete complex behavior of the actual network implementations.
This is very attractive since there are only few types of middleboxes which occur in practice.
Another interesting result may be showing that the correctness of the network is preserved by
replacing a middlebox implementation, e.g, from Snort~\cite{Snort} to Bro~\cite{Bro}.

It may be possible to check that the concrete middlebox implementation adheres to the abstract
specification using Hoare's method.
In general this can be quite hard for complicated middleboxes since the code and its specifications are rather complex.
It may be interesting to identify interesting properties which can be checked for the actual middlebox code.
For example, can we check if a change to the Firewall rules or Intrusion Detection System code does not lead to a new packet being transmitted?


\subsubsection{RONO Middleboxes}
Let $G$ be a network of middleboxes and $P$ be a property of $G$, for example some network isolation requirements.
We write $G \models P$ to denote the fact that $G$ satisfies $P$.
A naive compositional verification rule has the form
\[
\begin{array}{l}
G_1 \models P_1, G_2 \models P_2
\\
\hline
(G_1 \cup G_2) \models P_1 \land P_2
\end{array}
\]
Unfortunately,  such a composition rule not usually hold for networks of middleboxes from many reasons.
The middleboxes do not usually commute with each other.
Like ADTs, different sequences of applications of middleboxes may result in very different packets and side-effects
on the internal states of the middleboxes.
Nevertheless, it seems that network operators usually know where to put middleboxes.

In order to come with composition rules for verification, it may be useful to identify the ``footprint'' of a network of middleboxes which effects traffic.
It may even be possible to come with different compositional rules for different propriety.
It was observed in the separation logic community, memory footprints are essential for composing programs manipulating dynamically allocated data structures.
In general middleboxes can implement arbitrary programs.
In \cite{corr:PandaLASS14} a new property for middleboxes which limits the part of the network which affects correctness.
It thus permits compositional reasoning.
A middlebox is \textbf{R}\/est \textbf{O}\/f \textbf{N}etwork \textbf{O}\/blivious (RONO) if its forwarding behavior
between any two hosts depends only on the traffic between these hosts.
RONO allows to separately reason about sub-topologies.
\notemooly{Do we want the formal definition here?}


\subsubsection{Correctness Preserving Transformations and Parametric Topologies}
It may be possible to show that certain correctness properties are preserved by the addition of certain middleboxes in certain ways.
For example, we may want show that the insertion of certain kinds of middleboxes e.g., WAN cannot lead to new violations of network isolation.
This will be very nice as it will give principles for changing network topologies.
Another open question is can one verify a parametric network of middleboxes?
For example, the Azure network seems to be built out many parallel paths for scalability.
Can we verify one path and then show that there are no interaction?
