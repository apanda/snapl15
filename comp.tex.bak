\newcommand{\lsyn}{\lbrack\!\lbrack}
\newcommand{\rsyn}{\rbrack\!\rbrack}
\newcommand{\semp}[1]{\lsyn #1 \rsyn}
\section{Compositional Reasoning on Networks of Middleboxes}
The holy grail of programming languages has been to provide mechanisms for building complex software systems using smaller components.
Ideally, it should be possible reason about the correctness of the system in a \emph{compositional} way --- The correctness of a
complex system should follow the correctness of the individual components.
For example, rely-guarantee~\cite{tse:MisraC81,ifip:Jones83}, is a compositional method for reasoning about concurrent systems.
Compositional methods reduce the cost of reasoning and enables reasoning about changes to the systems.
Compositional reasoning is especially attractive since verification technologies usually incur high costs.
In this section, we argue that middleboxes enable in many cases to reason compositionally on the correctness of the data-plane.

\subsection{Formalizing Middleboxes}
Let $P$ denotes the potentially infinite set of packets.
The semantics of a middlebox is a function  $m\colon P \times P^* \to 2^P$, i.e., for every input packet $p$, and a history of packets $h$, the middlebox
produces a set of packets $m(p, h)$.
The empty set of packets is produced when the packet is dropped.
A switch is a degenerate case in which $m(p, h) = \{h\}$.
NATs map local into global IP addresses.
A load balancer can rewrite the packet to enable different subsequent routing.
It can also change its policy as it sees more packets.
A cache proxy rewrites the first request to originate from the current node
and stores the response.
Packets with stored responses are re-routed to the source with the stored responses in the packet body .


\subsection{Middleboxes are ADTs}
Abstract data types (ADTs) are effective way to build reliable and efficient software.
Indeed data abstraction is one of the key techniques for reasoning about programs (e.g., see \cite{acta-inf:H72}.
It is not clear how to use abstract data types to handle the data plane which is viewed as a flat hardware
based system.
SDN controller programs are written in high level languages such as Python and Java which offer various modularity mechanisms.
However, these do not help with modularly handling the data-plane.

We believe that middleboxes are somewhat analogous to ADTs.
We have already shown that the abstract specification of middleboxes is much simpler than their concrete implementations.
It should be possible to verify certain correctness properties of the network, e.g., packet isolation without the need to analyze the concrete complex behavior of the actual network implementations.
This is very attractive since there are only few types of middleboxes which occur in practice.
Another interesting result may be showing that the correctness of the network is preserved by
replacing a middlebox implementation, e.g, from Snort~\cite{Snort} to Bro~\cite{Bro}.

It may be possible to check that the concrete middlebox implementation adheres to the abstract
specification using Hoare's method.
In general this can be quite hard for complicated middleboxes since the code and its specifications are rather complex.
It may be interesting to identify interesting properties which can be checked for the actual middlebox code.
For example, can we check if a change to the Firewall or Intrusion Detection System does not lead to a new packet being transmitted?

\subsection{Exploring Encapsulation}
The local state of each the middleboxes is isolated from the rest of the network which simplifies the task of reasoning about networks of middleboxes.
Formally, \textbf{an abstract model of middlebox} $m$ can be captured as function
\[
\hat{m}\colon (S_m \times P) \to (S_m \times 2^P)
\]
where $S_m$ is the local abstract states of $m$ and $P$ is the set of packets and
an \textbf{initial abstract state} $s_0 \in S_m$.
We say that such an abstract model $\hat{m}$ \textbf{realizes} a middlebox $m\colon P \times P^* \to 2^P$
when for every history $h \in P^*$ and packet $p \in P$,
\[
m(h, p) = \widehat{m}(\semp{h}(s_0),p)_2
\]
where $\semp{h}\colon S_m \to S_m$ denotes the middlebox abstract state after the execution of the history $h$.
It is inductively defined by:
\[
\semp{\epsilon}(s_0) = s_0
\]
and
\[
\semp{h.p'}(s_0) = \widehat{m}(\semp{h}(s_0), p')_1
\]

Thus, an invocation of $m$ can change its local state and produces a set of forwarded packets.
For example, if two middleboxes $m_1$ and $m_2$ do not change the packet then their effect commutes.
However, most middleboxes do not commute.
For example, even a Firewall does not usually commute with a Load-Balancer\notemooly{Is there a better example}.



\subsection{RONO Middleboxes}
In \cite{CCR:PLASS15} we describe a new criterion for middleboxes which permits compositional reasoning.
A middlebox is \textbf{R}\/est \textbf{O}\/f \textbf{N}etwork \textbf{O}\/blivious (RONO) if COMPLETE.


\subsection{Parametric Topologies and Correctness Preserving Transformations}
In practice we expect network topologies to be simple.
Therefore, it will be possible to develop methods which reason about composing topologies in certain ways.

It may be possible to show that certain correctness properties are preserved by the addition of certain middleboxes in certain ways.
For example, we may want to insert a Proxy on some links w/o violating network isolation.
