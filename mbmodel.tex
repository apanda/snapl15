\section{How to Model Middleboxes?}
\label{sec:mbmodel}
The natural approach for verifying mutable datapaths would be to apply standard program verification techniques to the code in each middlebox (and then extend this to the network as a whole, which is the problem we address in the next section). The practical problem with this approach is that middlebox code is typically proprietary, and any approach that relies on middlebox vendors releasing their code is doomed to fail.
Moreover, there is a deeper conceptual problem with this approach. The invariants specified by network operators often use abstractions, such as user identity, host identity, application-type (of the traffic), and whether or not the traffic is ``suspicious'' (\eg after deep packet inspection). In fact, recent efforts to build policy languages are built around a similar set of abstractions~\cite{congress}.

The correctness of these abstractions often {\em cannot} be fundamentally verified (\eg a middlebox in the middle of the network cannot always know for sure which host the packet came from given the various forms of spoofing or relaying available) or even precisely defined (\eg what is suspicious traffic?). Yet these abstractions are quite useful (and already widely used) in practice, and operators are willing to live with their approximations (\eg various techniques can be used to limit spoofing so that in some contexts host identification can rely on IP or MAC addresses without great risk).

\cbstart
To allow reasoning in terms of high level abstractions without worrying about the various approximations that go into their definition, we model middleboxes in two parts: a reasonably simple abstract model that captures the action of a middlebox in terms of high-level primitives and an {\em oracle} that is described by the set of abstractions it supports. The oracle maps packets to one or more abstract classes (\eg this packet is from a Skype flow from host A and user X to host B and user Y), while the abstract model describes how the middlebox forwards packets belonging to different abstract classes (\eg a middlebox might be configured to drop all suspicious packets, or only allow packets from host A to reach host B but no other hosts). For instance, for an IDS that identifies suspicious packets and forwards them to a scrubbing box, the oracle part of the model determines which packets are suspicious and the abstract model is what dictates that such packets are forwarded to a scrubbing box.
\cbend

The oracles in different middleboxes may use very different techniques to implement these abstractions. While operators care about the quality of this mapping, the goal of our network verification approach is to check that a network configuration correctly enforces invariants {\em assuming that the oracles are correct}. Also, different oracles may  support different sets of abstractions (\eg some firewalls may be able to identify Skype traffic, and others not), and this would be described as part of the middlebox model.

\cbstart
In contrast, the abstract models are fairly generic in the sense that the abstract model of a firewall applies to most firewalls. The degree of detail in these abstract models depends, to some degree, on the kind of invariants one wants to check.  The basic network invariants of reachability and isolation only require that the abstract model describe the forwarding behavior (\eg if and where each packet is forwarded). Our initial target is verifying these basic invariants, as these properties are by far the most important safety property provided by networks. If one wants to support performance-oriented invariants then the abstract model must include timing information (\eg what packet delays might occur), and other extensions are needed to consider invariants that address simultaneity (two properties always hold at the same time). For simplicity, we do not consider such extension here.
\cbend

Separating middlebox models into an abstract model and an oracle has several advantages.
\begin{itemize}
\item It captures the fact that there are a limited number of middlebox ``types'', with many implementations of each. The abstract model applies to all of these implementations (and is fairly simple in nature), and implementations mainly differ in the abstractions and features offered by the oracle.  Thus, our verification approach --- which asks whether invariants are enforced assuming the oracles are right --- can be applied independent of the implementations.
\item It differentiates between improvements in the oracle (\eg adding new abstractions to recognize application types), which is what consumes the bulk of the development effort, and verifying correctness of the network configuration.
\item It could change the vendor ecosystem by allowing (or requiring) vendors to provide the abstract model (and a description of which abstractions their oracle supports) along with their middlebox. Network operators could then perform verification, while vendors could keep their implementations private.
\item While it would be useful for vendors to {\em verify} that their code obeys the abstract model (using standard code verification methods), what makes this approach particularly appealing is that vendors and operators alike can {\em enforce} that the middleboxes obey the abstract model. The abstract models (and we have built several of them) are so simple that they execute much faster than the actual middlebox implementation, so one can run these abstract models in parallel and ensure that the middleboxes take no action that does not obey the abstract model.
\end{itemize}
