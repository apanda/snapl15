\section{How to Model Middleboxes?}
\label{sec:mbmodel}
The natural approach for verifying mutable datapaths would be to apply standard program verification techniques to the code in each middlebox (and then somehow extend this to the network as a whole, which is the problem we address in the next section). The practical problem with this approach is that middlebox code is typically proprietary, and any approach that relies on middlebox vendors releasing their code is doomed to fail.
Moreover, there is a deeper conceptual problem with this approach. The invariants specified by network operators often use abstractions, such as user identity, host identity, application-type (of the traffic), and whether or not the traffic is ``suspicious'' (e.g., after deep packet inspection). In fact, recent efforts to build policy languages are built around a similar set of abstractions.

The correctness of these abstractions often {\em cannot} be fundamentally verified (e.g., a middlebox in the middle of the network cannot always know for sure which host the packet came from given the various forms of spoofing or relaying available) or even precisely defined (e.g., what is suspicious traffic?). Yet these abstractions are quite useful (and already widely used) in practice, and operators are willing to live with their approximations (e.g., various techniques can be used to limit spoofing so that in some contexts host identification can use IP or MAC addresses as the basis for identification without great risk).

To allow reasoning in terms of high level abstractions without worrying about the various approximations that go into their definition, we model middleboxes in two parts: a reasonably simple abstract model that captures the action of a middlebox in terms of high-level primitives and an Oracle that is described by the set of abstractions it supports. The Oracle maps packets to one or more abstractions (e.g., this packet is from a Skype flow from host A and user X to host B and user Y), while the abstract model describes how the middlebox uses these abstractions (e.g., a middlebox might be configured to drop all suspicious packets, or only allow packets from host A to reach host B but no other hosts). For instance, for an IDS that identifies suspicious packets and forwards them to a scrubbing box, the Oracle part of the model is what determines which packets are suspicious and the abstract model is what dictates that such packets are forwarded to a scrubbing box.

The Oracles in different middleboxes may use very different techniques to map packets to abstractions. While operators care about the quality of this mapping, the goal of our network verification approach is to check that a network configuration correctly enforces invariants {\em assuming that the Oracles are correct}. Also, different Oracles may  support different sets of abstractions (e.g., some firewalls may be able to identify Skype traffic, and others not), and this would be described as part of the middlebox model.

In constrast, the abstract models are fairly generic in the sense that the abstract model of a firewall applies to most firewalls. The degree of detail in these abstract models depend, to some degree, on the kind of invariants one wants to enforce.  The basic network invariants of reachability and isolation only require that the abstract model describe the forwarding behavior (e.g., if and where each packet is forwarded). These basic invariants of reachability and isolation are our initial target, as this is by far the most important use of network verification. If one wants to support performance-oriented invariants then the abstract model must include timing information (e.g., what packet delays might occur). This is beyond the scope of our current efforts.

The separation of middlebox models into an abstract model and an Oracle has several advantages.
\begin{itemize}
\item It captures the fact that there are a limited number of middlebox ``types'', with many implementations of each. The abstract model applies to all of these implementations (and is fairly simple in nature), while the Oracle typically differs between implementations.  Thus, our verification approach, which asks whether invariants are enforced assuming the Oracles are right, can be applied independent of the implementations.
\item It differentiates between improvements in the Oracle (e.g., finding better methods for identifying application traffic), which is what consumes the bulk of the development effort, and verifying correctness of the network configuration.
\item It could change the vendor ecosystem by allowing (or requiring) vendors to provide the abstract model (and a description of which abstractions their Oracle supports) along with their middlebox.
Network operators could then perform verification, while vendors could keep their implementations private.
\item While it would be useful for vendors to {\em verify} that their code obeys the abstract model (using standard code verification methods), what makes this approach particularly appealing is that vendors and operators alike can {\em enforce} that the middleboxes obey the abstract model. The abstract models (and we have built several of them) are so simple that they execute much faster than the actual middlebox implementation, so one can run these abstract models in parallel and ensure that the middleboxes take no action that does not obey the abstract model.


Configuration: what does the abstract model

Placement: 
\end{itemize}

% \notepanda{The goal is to help network operators verify the correctness of their network configuration before deployment.}
% \notepanda{Configurations and invariants
% are both provided by network administrators.}

\eat{
\begin{lstlisting}[caption={Model for an IDS},label=list:ids,captionpos=t,float,abovecaptionskip=-\medskipamount]
oracle suspicious? (history: Seq[Packet], packet: Packet) : Boolean;


model ids (n: Node, p: Packet) = {
  state history: Seq[Packet];
  when ids_classifier(history, p) =>
      history = history + p;
      forward {p}
  default =>
      history = history + p;
      forward {}
}
\end{lstlisting}

Next we look at the problem of specifying generic middleboxes. For all the middlebox types we have looked at so far, splitting the middlebox into a generic
model and an oracle, allows us to specify the the generic models without loops. This is reasonable since middleboxes must forward packets in bounded time to
keep up with the network and can only touch a bounded amount of state for each packet. }
