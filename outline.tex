\section{Outline}
\begin{outline}
\1 Divide network into two halves
    \2 An arbitrarily complicated control plane; verifying properties for which can be undecidable.
    \2 A simpler dataplane, for which a variety of abstract models have been suggested.
\1 Lots of recent interesting in network verification; largely inspired by software-defined networking.
\1 Most of the commonly suggested models assume that the data plane in a network is stateless
    \2 FlowLog: Explicitly makes this assumption
    \2 NetKAT: The semantic allows combinations of stateless policies, the results of which are ultimately stateless. (Policies can only examine and depend on the first packet in a packet history) [NB: I am correct about this, I read the paper very carefully; however my wording is stupid]
    \2 Frenetic and HSA's network transfer functions: These are pure-functions from located packets to located packets, and hence don't allow state changes.
...
\1 In these models, the assumption, mistakenly adopted from early papers in SDN is that any stateful computation is carried out at the controller.
    \2 A variety of languages and verification tools verify the data plane configuration generated by these controllers. Tools from above help reasoning about these configurations.
    \2 More importantly, various extensions look at doing relatively fast, incremental checks on this data path configuration.
\1 But the reality in the network is a bit more complicated
    \2 Even very simple examples like Learning Switches are not implemented using the control plane
    \2 High latency, not high enough throughput makes controllers ill-suited to handle these examples.
    \2 More importantly, middleboxes abound:
        \3 Used to provide desirable security and performance optimization functions.
        \3 Can be arbitrarily complicated.
        \3 Importantly, stateful, behavior evolves over time.
    \2 Verification (and all the other tasks for which we are using these network models) is still an important concern in networks with these boxes.
\1 Gaps when we consider stateful networks
    \2 Unrepresentable in the current models, the models themselves need to be expanded.
    \2 Harder to prove decidability
    \2 Must reason about unbounded sequences of packets; long running mutable system.
\1 Challenge to the community
    \2 Come up with a set of assumptions and tools that help us reason about these networks.
\1 A first idea
    \2 Limit the total amount of state we have to reason about. A few steps to this.
    \2 Abstract middleboxes as loop free constructs. Loop freedom here means we only need to consider finite subsequences of packets, maybe getting us closer to decidability when analyzing a single middlebox. [This is actually risky, I have to work through this some more, but I think it is mostly correct] The number of sequences to be analyzed is itself a function of the description size.
        \3 Any middlebox is: simple abstract model which is generic and uses ``abstract'' data types + oracle (implementation of abstract-datatypes)
    \2 Consider loop-free toplogies (between a source-destination pair): this ensures that we only have to deal with finite combinations of middleboxes, each of which only needs 
    \2 RONO, to reason about a single, directed path through the network. This helps in a few ways:
        \3 Reduces the number of paths through a single middlebox we need to consider.
        \3 Eliminates natural loops: at most only need to consider a linear path to the destination and back (which can be considered a loop-free path).
    \2 Combine these three, we can reason about a composition of a finite set of middleboxes, each of whose behavior depends on a finite amount of state. Need to explore a finite set to decide if a policy is violated.
\1 Problems
    \2 Extend RONO naturally to tasks other than reachability.
\end{outline}